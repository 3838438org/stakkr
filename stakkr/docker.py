"""Docker functions to get info about containers"""

from docker import APIClient, client as DockerClient, utils, errors
from requests.exceptions import ConnectionError
CTS_INFO = dict()
RUNNING_CTS = 0
PARAMS = utils.kwargs_from_env()
BASE_URL = None if 'BASE_URL' not in PARAMS else PARAMS['BASE_URL']
TLS = None if 'TLS' not in PARAMS else PARAMS['TLS']
APICLIENT = APIClient(base_url=BASE_URL, tls=TLS)
CLIENT = DockerClient.from_env()


def block_ct_ports(service: str, ports: list, project_name: str) -> tuple:
    """Run iptables commands to block a list of port on a specific container"""

    try:
        container = CLIENT.containers.get(get_ct_item(service, 'id'))
    except Exception:
        return (False, '{} is not started, no port to block'.format(service))

    iptables = container.exec_run(['which', 'iptables']).decode().strip()
    if iptables == '':
        return (True, "Can't block ports on {}, is iptables installed ?".format(service))

    _allow_contact_subnet(project_name, container)

    # Now for each port, add an iptable rule
    for port in ports:
        rule = ['OUTPUT', '-p', 'tcp', '--dport', port, '-j', 'REJECT']
        try:
            container.exec_run([iptables, '-D'] + rule)
        finally:
            container.exec_run([iptables, '-A'] + rule)

    return (False, 'Blocked ports {} on container {}'.format(', '.join(ports), service))


def check_cts_are_running(project_name: str):
    """Throws an error if cts are not running"""

    global CTS_INFO

    RUNNING_CTS, CTS_INFO = get_running_containers(project_name)
    if RUNNING_CTS is 0:
        raise SystemError('Have you started your server with the start action ?')

    return (RUNNING_CTS, CTS_INFO)


def container_running(container: str):
    """Returns True if the container is running else False"""

    try:
        ct_data = APICLIENT.inspect_container(container)

        return ct_data['State']['Running']
    except Exception:
        return False


def get_client():
    """Return the initialized client"""

    return CLIENT


def get_ct_item(compose_name: str, item_name: str):
    """Get a value from a container, such as name or IP"""

    if len(CTS_INFO) is 0:
        raise RuntimeError('Before getting an info from a ct, run check_cts_are_running()')

    for ct_id, ct_data in CTS_INFO.items():
        if ct_data['compose_name'] == compose_name:
            return ct_data[item_name]

    return ''


def get_ct_name(container: str):
    """Returns the system name of a container, generated by docker-compose"""

    ct_name = get_ct_item(container, 'name')
    if ct_name == '':
        raise Exception('{} does not seem to be started ...'.format(container))

    return ct_name


def get_running_containers(project_name: str) -> tuple:
    """Get the number of running containers and theirs details for the current stakkr instance"""

    filters = {
        'name': '{}_'.format(project_name),
        'status': 'running',
        'network': '{}_stakkr'.format(project_name).replace('-', '')}

    try:
        cts = CLIENT.containers.list(filters=filters)
    except ConnectionError:
        raise Exception('Make sure docker is installed and running')

    for container in cts:
        container_info = _extract_container_info(project_name, container.id)
        CTS_INFO[container_info['name']] = container_info

    return (len(cts), CTS_INFO)


def get_running_containers_name(project_name: str) -> list:
    """Get a list of compose names of running containers for the current stakkr instance"""

    num_cts, cts = get_running_containers(project_name)

    return sorted([ct_data['compose_name'] for docker_name, ct_data in cts.items()])


def guess_shell(service: str) -> str:
    """By searching for binaries, guess what could be the primary shell available"""

    container = CLIENT.containers.get(get_ct_item(service, 'id'))

    cmd = 'which -a bash sh'
    shells = container.exec_run(cmd, stdout=True, stderr=False).splitlines()
    if b'/bin/bash' in shells:
        return '/bin/bash'
    elif b'/bin/sh' in shells:
        return '/bin/sh'

    raise EnvironmentError('Could not find a shell for that container')


def _extract_container_info(project_name: str, ct_id: str):
    """Get a hash of info about a container : name, ports, image, ip ..."""

    try:
        ct_data = APICLIENT.inspect_container(ct_id)
        ports = ct_data['Config']['ExposedPorts'].keys() if 'ExposedPorts' in ct_data['Config'] else []
        ct_info = {
            'id': ct_id,
            'name': ct_data['Name'].lstrip('/'),
            'compose_name': ct_data['Config']['Labels']['com.docker.compose.service'],
            'ports': ports,
            'image': ct_data['Config']['Image'],
            'ip': _get_ip_from_networks(project_name, ct_data['NetworkSettings']['Networks']),
            'running': ct_data['State']['Running']
        }

        return ct_info
    except Exception:
        return None


def _get_ip_from_networks(project_name: str, networks: list):
    """Get a list of IPs for a network"""

    project_name = project_name.replace('-', '')
    network_settings = {}
    if '{}_stakkr'.format(project_name) in networks:
        network_settings = networks['{}_stakkr'.format(project_name)]

    return network_settings['IPAddress'] if 'IPAddress' in network_settings else ''


def create_network(network: str):
    """Create a Network"""

    if network_exists(network):
        return False

    return CLIENT.networks.create(network, driver='bridge').id


def get_subnet(project_name: str):
    """Find the subnet of the current project"""

    network_info = CLIENT.networks.get(project_name.replace('-', '') + '_stakkr').attrs

    return network_info['IPAM']['Config'][0]['Subnet'].split('/')[0]


def get_switch_ip():
    """find the main docker daemon IP to add routes"""

    import socket

    cmd = r"""/bin/sh -c "ip addr show hvint0 | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}'" """
    res = CLIENT.containers.run('alpine', remove=True, tty=True, privileged=True,
                                network_mode='host', pid_mode='host', command=cmd)
    ip_addr = res.strip().decode()

    try:
        socket.inet_aton(ip_addr)
        return ip_addr
    except socket.error:
        raise ValueError('{} is not a valid ip, check docker is running')


def network_exists(network: str):
    """True if a network exists in docker, else False"""

    try:
        CLIENT.networks.get(network)
        return True
    except errors.NotFound:
        return False


def add_container_to_network(container: str, network: str):
    """Attach a container to a network"""

    if _container_in_network(container, network) is True:
        return False

    docker_network = CLIENT.networks.get(network)
    docker_network.connect(container)

    return True


def _allow_contact_subnet(project_name: str, container: str) -> None:
    iptables = container.exec_run(['which', 'iptables']).decode().strip()
    if iptables == '':
        return False

    subnet = get_subnet(project_name) + '/24'
    # Allow internal network
    try:
        container.exec_run([iptables, '-D', 'OUTPUT', '-d', subnet, '-j', 'ACCEPT'])
    finally:
        container.exec_run([iptables, '-A', 'OUTPUT', '-d', subnet, '-j', 'ACCEPT'])


def _container_in_network(container: str, expected_network: str):
    """Returns True if a container is in a network else false. Used by add_container_to_network"""

    try:
        ct_data = APICLIENT.inspect_container(container)
    except Exception:
        raise SystemError('Container {} does not seem to exist'.format(container))

    for connected_network in ct_data['NetworkSettings']['Networks'].keys():
        if connected_network == expected_network:
            return True

    return False
